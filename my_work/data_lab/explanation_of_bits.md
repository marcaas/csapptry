# CS:APP 数据实验

## <请输入你的姓名和ID>
marcaas
## bits.c - 本次实验中你要解决的源文件.

***注意: 不要引用头文件 <stdio.h> ; 它会混淆dlc编辑器. 你仍然可以使用printf去检查漏洞就算没有 <stdio.h> , 尽管你可能会受到编辑器警告. 总的来说, 忽略编辑器的警告是一个不好的行为, 但在这里不作要求.***

*#if 0*

## 指导建议:

### 第一步: 仔细阅读下面的建议

你将要在源文件中对一些函数进行编辑并提交你对于这次数据实验的解决方法.

#### 整数代码的规则:

  *例子:*
  ```
  int Funct(arg1, arg2, ...) {
        /* brief description of how your implementation works */
        int var1 = Expr1;
        ...
        int varM = ExprM;
          varJ = ExprJ;
        ...
        varN = ExprN;
        return ExprR;
    }
  ```

##### 每一个 "Expr" 都有如下要求: 
1. 0到255 (0xFF) 的整形常数. 
2. 函数参数和局部变量 (不可以是全局变量) .
3. ! ~
4. & ^ | + << >>

*某些问题对操作的限制可能更多. 每一个 "Expr" 可能又多个操作组成. 你不必每行只写一个操作.*

##### 禁止使用:
  1. 禁用条件控制如 if, do, while, for, switch等. 
  2. 禁用宏指令. 
  3. 禁用额外的函数. 
  4. 禁止调用函数.
  5. 禁止使用其他操作, 如 &&, ||, -, ?等.
  6. 禁止使用任何形式的转换. 
  7. 除了int形式外禁用任何其他数据类型. 这意味着你不能使用数组, 结构体以及联合.

##### 你可以假设你的机器:
  1. 使用二进制补码, 32位整数寄存器.
  2. 使用算术右移.
  3. 当移位超过数据长度时不可预测行为 (?) .

  *例子:*
  ```
  /*
   * pow2plus1 - returns 2^x + 1, where 0 <= x <= 31
   */
  int pow2plus1(int x) {
     /* exploit ability of shifts to compute powers of 2 */
     return (1 << x) + 1;
  }

  /*
   * pow2plus4 - returns 2^x + 4, where 0 <= x <= 31
   */
  int pow2plus4(int x) {
     /* exploit ability of shifts to compute powers of 2 */
     int result = (1 << x);
     result += 4;
     return result;
  }
  ```

#### 浮点数代码的规则:
  
  *对于需要让你进行浮点操作的问题, 代码规则没有那么严格, 你可以使用循环以及条件控制. 你可以使用整形数以及无符号数. 你可以使用任意整数以及无符号常数.*

##### 禁止使用:
  1. 禁用宏指令.
  2. 禁用额外的函数.
  3. 禁止调用函数.
  4. 禁用任何形式的转换.
  5. 禁用整数以及无符号数以外的数据类型,这意味着你不能使用数组, 结构体以及联合.
  6. 禁用任何浮点数据类型, 操作以及常数.

##### 提示:
  1. 使用dlc (data lab checker) 编辑器 (在handout中定义) 去检查你操作的合法性.
  2. 每一个函数都对你能使用的操作 (! ~ & ^ | + << >>) 数量进行了最大值限制. 这个限制会被dlc检查, '=' 并不计算在内, 你可以随意使用.
  3. 使用btest测试工具检查你的函数是否正确.
  4. 使用BDD checker去核实你的函数.
  5. ?

### 第二步: 根据规则修改下面的函数.
#### 检验方法
  1. 使用dlc文件去检查你的方法是否符合规则.
  2. 使用BDD checker去检查你的结果的正确率. (? BDD checker没搞懂是哪个) 